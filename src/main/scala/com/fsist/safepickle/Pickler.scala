package com.fsist.safepickle

import scala.reflect.runtime.universe._
import org.apache.commons.codec.binary.Base64

import scala.annotation.implicitNotFound

/** A way to pickle or unpickle a type. */
@implicitNotFound("Implicit Pickler for ${T} not found")
trait Pickler[T] {
  /** A type tag for `T`. This is used only for implementing `typeName`; runtime reflection is never used. */
  def ttag: TypeTag[T]

  /** Should write the value `t` to the `writer`. If the type `T` contains sub-types for which we have sub-picklers,
    * they should be used by calling `writer.write[T](pickler)` for those types.
    *
    * WARNING: do not call this method directly; use `PickleWriter.write` with this pickler instead.
    *
    * @param emitObjectStart If writing an object, and this argument is true, the pickler will write an ObjectStart token.
    *                        If false, it will assume an object scope has already been opened, and start emitting attributes.
    */
  def pickle(t: T, writer: PickleWriter[_], emitObjectStart: Boolean = true): Unit

  /** Should read and parse the reader's current token without advancing it. If the type `T` contains sub-types for
    * which we have sub-picklers, they should be used by calling `reader.read[T](pickler)` for those types.
    * 
    * If reading a complex value (object, array) or a series of values, consisting of multiple Reader tokens, 
    * should assume the current token when called is the first token to be read, and should leave the last token
    * that was read and processed as the current token.
    *
    * WARNING: do not call this method directly; use `PickleReader.read` with this pickler instead.
    *
    * @param expectObjectStart if reading an object, and this argument is true, expect the current reader token to be
    *                          the object start. If it is false, expect the current token to be the first attribute name
    *                          inside the object. If not reading an object, ignore this argument.
    * @throws UnpicklingException if the reader provides unexpected input
    */
  def unpickle(reader: PickleReader, expectObjectStart: Boolean = true): T

  /** The full name of the type `T`. */
  lazy val typeName: String = ttag.tpe.typeSymbol.fullName

  /** A schema describing the pickled form generated by this pickler. */
  def schema: Schema
}

object Pickler extends PrimitivePicklersMixin with CollectionPicklersMixin {

  /** Returns a Pickler[T] that delegates to the pickler returned by `getPickler`.
    *
    * This helps resolve loops in indirectly self-referential types. If you have this hierarchy:
    *
    * case class A(b: B)
    * case class B(a: Option[A])
    *
    * Then Autogen[A] will call Autogen[B] which will call Autogen[A] again. The solution looks like this:
    *
    * object A {
    *   implicit val pickler = Pickler.delegate(thePickler)
    *   private val thePickler = Autogen[A]
    * }
    */
  def delegate[T](getPickler: => Pickler[T]): Pickler[T] = new Pickler[T] {
    private lazy val pickler = getPickler
    override def ttag: TypeTag[T] = pickler.ttag
    override def pickle(t: T, writer: PickleWriter[_], emitObjectStart: Boolean): Unit =
      pickler.pickle(t, writer, emitObjectStart)
    override def unpickle(reader: PickleReader, expectObjectStart: Boolean): T =
      pickler.unpickle(reader, expectObjectStart)
    override def schema: Schema = pickler.schema
  }
}

class UnpicklingException(msg: String, cause: Throwable = null) extends Exception(msg, cause)
object UnpicklingException {
  def apply(msg: String, cause: Throwable = null) = new UnpicklingException(msg, cause)
}

case class UnexpectedEofException(expected: String) extends UnpicklingException(s"Unexpected EOF (expected: $expected)")

/** Implicit definitions of picklers for standard types.
  *
  * This trait exists as a mixin so that types extending it can re-export its implicit definitions.
  * If you don't need that, use the PrimitivePicklers object.
  *
  * NOTE: in non-generic situations, when you know the type T you're dealing with statically, you don't have to use these
  * as sub-picklers; you can call the methods PickleWriter.writeXxx and PickleReader.readXxx directly instead, which is
  * more efficient and clearer to read.
  */
trait PrimitivePicklersMixin {

  implicit object ShortPickler extends Pickler[Short] {
    final override def ttag = typeTag[Short]
    final override def pickle(short: Short, writer: PickleWriter[_], emitObjectStart: Boolean = true): Unit =
      writer.writeInt(short)

    final override def unpickle(reader: PickleReader, expectObjectStart: Boolean = true): Short =
      reader.int.toShort
    override def schema: Schema = Schema.short
  }

  implicit object IntPickler extends Pickler[Int] {
    final override def ttag = typeTag[Int]
    final override def pickle(int: Int, writer: PickleWriter[_], emitObjectStart: Boolean = true): Unit =
      writer.writeInt(int)

    final override def unpickle(reader: PickleReader, expectObjectStart: Boolean = true): Int =
      reader.int

    override def schema: Schema = Schema.int
  }

  implicit object LongPickler extends Pickler[Long] {
    final override def ttag = typeTag[Long]
    final override def pickle(long: Long, writer: PickleWriter[_], emitObjectStart: Boolean = true): Unit =
      writer.writeLong(long)

    final override def unpickle(reader: PickleReader, expectObjectStart: Boolean = true): Long =
      reader.long

    override def schema: Schema = Schema.long
  }

  implicit object FloatPickler extends Pickler[Float] {
    final override def ttag = typeTag[Float]
    final override def pickle(float: Float, writer: PickleWriter[_], emitObjectStart: Boolean = true): Unit =
      writer.writeFloat(float)

    final override def unpickle(reader: PickleReader, expectObjectStart: Boolean = true): Float =
      reader.float

    override def schema: Schema = Schema.float
  }

  implicit object DoublePickler extends Pickler[Double] {
    final override def ttag = typeTag[Double]
    final override def pickle(double: Double, writer: PickleWriter[_], emitObjectStart: Boolean = true): Unit =
      writer.writeDouble(double)

    final override def unpickle(reader: PickleReader, expectObjectStart: Boolean = true): Double =
      reader.double

    override def schema: Schema = Schema.double
  }

  implicit object BooleanPickler extends Pickler[Boolean] {
    final override def ttag = typeTag[Boolean]
    final override def pickle(boolean: Boolean, writer: PickleWriter[_], emitObjectStart: Boolean = true): Unit =
      writer.writeBoolean(boolean)

    final override def unpickle(reader: PickleReader, expectObjectStart: Boolean = true): Boolean =
      reader.boolean

    override def schema: Schema = Schema.boolean
  }

  implicit object StringPickler extends Pickler[String] {
    final override def ttag = typeTag[String]
    final override def pickle(string: String, writer: PickleWriter[_], emitObjectStart: Boolean = true): Unit =
      writer.writeString(string)

    final override def unpickle(reader: PickleReader, expectObjectStart: Boolean = true): String =
      reader.string

    override def schema: Schema = Schema.string
  }

  implicit object NullPickler extends Pickler[Null] {
    final override def ttag = typeTag[Null]
    final override def pickle(Null: Null, writer: PickleWriter[_], emitObjectStart: Boolean = true): Unit =
      writer.writeNull()

    final override def unpickle(reader: PickleReader, expectObjectStart: Boolean = true): Null = {
      reader.assertTokenType(TokenType.Null)
      null
    }

    override def schema: Schema = Schema.nul
  }

  /** Byte array pickler that writes the base64 value of the array as a string. */
  implicit object ByteArrayPickler extends Pickler[Array[Byte]] {
    final override def ttag = typeTag[Array[Byte]]
    final override def pickle(t: Array[Byte], writer: PickleWriter[_], emitObjectStart: Boolean): Unit = {
      writer.writeString(Base64.encodeBase64String(t))
    }

    final override def unpickle(reader: PickleReader, expectObjectStart: Boolean): Array[Byte] = {
      Base64.decodeBase64(reader.string)
    }

    override def schema: Schema = Schema.string
  }
}

/** Implicit definitions of picklers for standard types. */
object PrimitivePicklers extends PrimitivePicklersMixin

/** Pickles values of type `T` by converting them to values of type `Other`, which has an `otherPickler` provided. */
abstract class ConvertPickler[T, Other](implicit val otherPickler: Pickler[Other], val ttag: TypeTag[T]) extends Pickler[T]{
  def convertTo(t: T): Other
  def convertFrom(other: Other): T

  def pickle(t: T, writer: PickleWriter[_], emitObjectStart: Boolean = true): Unit =
    otherPickler.pickle(convertTo(t), writer, emitObjectStart)

  def unpickle(reader: PickleReader, expectObjectStart: Boolean = true): T =
    convertFrom(otherPickler.unpickle(reader, expectObjectStart))

  override def schema: Schema = otherPickler.schema
}

/** A refining of [[ConvertPickler]] for converting types to Strings using their `toString` method. */
abstract class ConvertToStringPickler[T](implicit ttag: TypeTag[T]) extends ConvertPickler[T, String]()(PrimitivePicklers.StringPickler, ttag) {
  def convertTo(t: T): String = t.toString
}
